\documentclass[../../main.tex]{subfiles}

\begin{document}

Design of the approach for a Rubik's cube detection and extraction was a tough thing. While it was easy to generate ideas meanwhile it was hard to prove that those ideas can survive experiments due to the quality of the image and large variety of algorithms that give good results in different situations. Basically, the design of this project contained multiple separate stages to complete the final goal, which was extract, map, solve and display the solution using 3D model. There was also tracking opportunity idea due to similarities of ideas for achieving extraction and tracking \cite{puzzle_games_solver_q4_zakharov}.

\subsubsection*{Extraction}

This is the hardest, from the research point of view, problem since it is related to the computer vision field of knowledge. There are large variety of approaches to deal with extraction. It could be done using feature key points or using contours and different line algorithms, blobs, histograms and etc. This work is an empirical research thus it was decided to try different approaches to see what fits better. The first try was the Sudoku solver project where all the basics of computer vision were tested, researched and analyzed. That project was a starting point and the place where contour detection for a square field detection was applied. It contained everything from detection to extraction and transforming. This idea was the first option to the assigned task. The next step was to find out how to do the same for a Rubik's cube face detection. The last idea was "Tracking and Mapping" group of algorithms. There are \ac{SLAM}, \ac{PTAM}, \ac{DTAM} and many others included to this category. Those algorithms were picked for the research because they allow to analyze 3D structures and the cube is also a 3D structure. The thoughts behind this were to find and track cubes faces because they are planes. Having 6 perpendicular planes their intersections could be found which are 8 points, cube's corners. Knowing all corners and tracking the cube faces allows to find if 4 corners are presented at the current view thus it is possible to extract the rectangle formed with these points.
There is also a simplified idea of using \ac{PTAM} for face extraction. It can be supposed that the image mostly contains a cube thus any plane that is found is cube face. To extract it the blob that includes all tracked key points should be found. This approach is open for research because this blob can be found in many possible ways.

\subsubsection*{Tracking}

"Tracking and Mapping" algorithms have tracking idea in their kernel. While for the extraction stage only their 3D analyses was necessary they created a possibility to make tracking of a cube through a video possible. There is also such a powerful tool for reducing measurement noise as a Kalman filter. Due to the predicting and updating nature this algorithm can be used for the tracking helper because when the face is not seen in a picture Kalman filter can still predict where it would go until it sees it again to update its model under the hood. Unfortunately, this topic is mostly derived from the previous one and does not affect any further steps thus it is not that critical.

\subsubsection*{Mapping}

This stage is a bridge between computer vision, rendering and solving parts of the project. There is some structure that represents the Rubik's cube. From the other side, there are 6 extracted faces and they should me mapped to that structure in order to do something with them. Mapping options vary depending on the picked extraction options. Using the contour way of extraction there is a list of 6 independent faces images while "Tracking and Mapping" allows to analyze corner positions and to know the relations between faces. That is why for the contour extraction way there should be some way to map faces correctly to the model. Since the pieces colors extraction is the next step for both ways it can be used for position analyses. The middle pieces colors have strict positions in relation to others thus it is easy to find where the face should go. But there is another problem, it is a face orientation. Mapping faces as they were extracted is a bad idea because with wrong orientation it will build wrong cube with impossible color combinations and it will not be possible to solve it while it is still possible to display this figure. The possible face orientation can be done in two ways also. There is an option to analyze possible cubies (some face pieces that form a cube piece) and to put new faces in correspondence with other already mapped faces. The second option is to map faces randomly and run some algorithm to detect whether this cube is correct, could be solved at all. If the result is "No" then rotate faces and try all possible combinations. This might be time consuming but will definitely give the result without any previous knowledge of possible relations between face pieces..

\subsubsection*{Solving}

This part of the project might be thought as an easy one but it is not true. There many different options to solve a cube and the implementation difficulties vary depending on the chosen algorithm. The first to think of might be brute-force algorithm but when for a 2 by 2 it is possible, for a 3 by 3 Rubik's cube it might take years to find the solution. Thus it is better to look at existing solutions. The algorithm for beginners was picked because it contains a small amount of formulas to know for solving a cube from scratch. This choice is argued by the fact that, for instance, Fridrich method contains 119 formulas and while it gives shorter and quicker solution it is hard to implement it without knowing all the formulas. To deal with this it is simply needed to run the formulas on the cube model depending on its state.

\subsubsection*{Rendering}
\label{subsec:rendering}

Rendering might be easy if you dealt with it before. This field of knowledge same as computer vision requires some mathematical background to be used. This stage also contains a couple of options how to be solved. The first one is to use OpenGL which requires some time to understand the technology and start using it. Another option is to implement simple software rendering engine that does not use \ac{GPU} but rather uses \ac{CPU} to render an image. This process is much more interesting while it still gives you some background for further usage of \ac{OpenGL}, for example.

\end{document}

