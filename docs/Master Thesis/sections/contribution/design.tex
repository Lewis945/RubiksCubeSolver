\documentclass[../../main.tex]{subfiles}

\begin{document}

Design of the approach for combination puzzles detection and extraction was not a trivial task. It was decided to use Rubik's cube as it is a simple cubic structure. While it was easy to generate ideas meanwhile it was hard to prove that those ideas can survive experiments due to the quality of the image and large variety of algorithms that give good results in different situations. The design of this project contained multiple separate stages to complete the final goal. They were extraction, mapping, solving and displaying the solution using 3D model. There was also tracking opportunity idea due to similarities of solutions for extraction and tracking \cite{puzzle_games_solver_q4_zakharov}.

\subsubsection*{Extraction}

This is the hardest, from the research point of view, problem since it is related to the computer vision field of knowledge. There are a large variety of approaches to deal with extraction. It could be done using feature points or using contours and different line algorithms, blobs, histograms and etc. This work is an empirical research thus it was decided to try different approaches to see what fits better. The first try was the Sudoku solver project where all the basics of computer vision were studied and tested. That project was a starting point and the place where contour detection for a square field detection was applied. It contained everything from detection to extraction and transformation. The Sudoku ideas were the first option to the assigned task. The next step was to find out how to do the same for a Rubik's cube face detection. The last idea was "Tracking and Mapping" group of algorithms. There are \ac{SLAM}, \ac{PTAM}, \ac{DTAM} and many others included to this category. Those algorithms were picked for the research because they allow to analyze 3D structures and the cube is also a 3D structure. The thoughts behind this were to find and track cubes faces because they are planes. Having 6 perpendicular planes their intersections could be found. They are eight points, cube's corners. Knowing all corners and the cube faces tracking allows to find if 4 corners are presented at the current view. This is achieved by projecting 3D points at each view. Hence, it is possible to extract the rectangle constructed with these points.
There is also a simplified idea of using \ac{PTAM} for face extraction. It can be supposed that the image mostly contains a cube thus any plane that is found is a cube face. To extract it the blob that includes all tracked key points should be found. This approach is open for research because this blob can be found in many possible ways.

\subsubsection*{Tracking}

"Tracking and Mapping" algorithms have tracking idea in their kernel. While for the extraction stage only their 3D analysis was necessary they made tracking of a cube using a video possible. There is also such a powerful tool for reducing measurement noise as a Kalman filter. Due to the predicting and updating nature this algorithm can be used as the tracking helper because when the face is not seen in the image Kalman filter can still predict where it would appear until it sees it again to update its model under the hood. Unfortunately, this topic is mostly derived from the previous one and does not affect any further steps thus it is not that critical for the following research.

\subsubsection*{Mapping}

This stage is a bridge between computer vision, rendering and solving parts of the project. There is some structure that represents the Rubik's cube. On the other hand, there are 6 extracted faces and they should me mapped to that structure in order to do something with them. Mapping options vary depending on the picked extraction options. Using the contour way of extraction there is a list of 6 independent faces images while "Tracking and Mapping" allows to analyze corner positions and to know the relations between faces. Hence, for the contour extraction way there should be some way to map faces correctly to the model. Since the color extraction is the next step for both options it can be used for position analysis. The colors of middle pieces have strict positions in relation to others thus it is easy to find where the face should go. However, there is another problem, it is a face orientation. Mapping faces as they were extracted is a bad idea because with wrong orientation it will build wrong cube with impossible color combinations and it will not be possible to solve it while it is still possible to display this figure. The possible face orientation can be done in two ways also. There is an option to analyze possible cubies (some face pieces that form a cube piece) and to put new faces in correspondence with other already mapped faces. The second option is to map faces randomly and run some algorithm to detect whether this cube is correct (could be solved in the end). If the result is "No" then rotate faces and try all possible combinations. This might be time consuming but will definitely give the result without any previous knowledge of possible relations between the face pieces.

\subsubsection*{Solving}

This part of the project might be thought as an easy one but it is not true. There are many different options to solve a cube and the implementation difficulties vary depending on the chosen algorithm. The first to think of might be brute-force algorithm if for a 2 by 2 cube it is possible, for a 3 by 3 Rubik's cube it might take years to find the solution. Thus it is better to look at existing solutions. The algorithm for beginners was picked because it contains a small amount of formulas to know for solving a cube from scratch. This choice is argued by the fact that, for instance, Fridrich method contains 119 formulas and while it gives shorter and quicker solution it is hard to implement it without knowing all the formulas. To deal with this it is needed to run the formulas on the cube model depending on its state.

\subsubsection*{Rendering}
\label{subsec:rendering}

Rendering might be easy if you dealt with it before. This field of knowledge same as computer vision requires some mathematical background to be used. This stage also contains a couple of options how to be solved. The first one is to use \ac{OpenGL} that requires some time to understand the technology and start using it. Another option is to implement simple software rendering engine that does not use \ac{GPU} but rather uses \ac{CPU} to render an image. This process is much more interesting while it still gives you some background for further usage of \ac{OpenGL}, for example.

\end{document}

